package migrate

import "github.com/belogik/goes"

// Migration contains instructions for migrating from one index to another. For the initial
// migration the FromIndex should be an empty string.
type Migration struct {
	FromIndex string
	ToIndex   string
	Settings  map[string]interface{}

	// Will be passed docs of the matching type and can return zero or more docs generated by that
	// input doc. This can be used to filter some docs out and to split some docs into smaller/other
	// docs. The types of the returned docs can be different from the type of the doc passed in. If a
	// given type is not contained in the map, docs of that type will be copied as-is to the new
	// index.
	TypeTransformers map[string]func(*goes.Document) []*goes.Document
}

// Transform uses the Migration's TypeTransformers to transform a doc into zero or more new docs.
func (m *Migration) Transform(doc *goes.Document) []*goes.Document {
	if trans, exists := m.TypeTransformers[doc.Type]; exists {
		return trans(doc)
	}
	return []*goes.Document{doc}
}

// DropAllTransformer can be used in Migration.TypeTransformers to drop all docs of a given type.
func DropAllTransformer(d *goes.Document) []*goes.Document {
	return nil
}

func compositeMigration(migrations []Migration) *Migration {
	if len(migrations) == 1 {
		return &migrations[0]
	}
	last := migrations[len(migrations)-1]
	return &Migration{
		FromIndex:        migrations[0].FromIndex,
		ToIndex:          last.ToIndex,
		Settings:         last.Settings,
		TypeTransformers: compositeTransformers(migrations),
	}
}

func compositeTransformers(migrations []Migration) map[string]func(*goes.Document) []*goes.Document {
	transform := func(doc *goes.Document) []*goes.Document {
		docs := []*goes.Document{doc}
		// Run any transformers for each of the migrations. Each transformer can return more than one
		// doc so we have to build up a slice of docs as we go along.
		for _, m := range migrations {
			newDocs := []*goes.Document{}
			for _, doc := range docs {
				newDocs = append(newDocs, m.Transform(doc)...)
			}
			docs = newDocs
		}
		return docs
	}

	transformers := map[string]func(*goes.Document) []*goes.Document{}
	for _, m := range migrations {
		for k := range m.TypeTransformers {
			transformers[k] = transform
		}
	}
	return transformers
}
